//
// Created by ozzadar on 2025-04-06.
//

#include <lights/text/font_loader.h>
#include <freetype/freetype.h>
#include <lights/rendering/render_pass.h>
#include <lights/util/image.h>
#include <spdlog/spdlog.h>

namespace OZZ {
	FontLoader::FontLoader() {
		spdlog::info("Loading font subsystem ...");
		if (FT_Init_FreeType(&library)) {
			spdlog::error("Could not initialize FreeType library");
			return;
		}
	}

	FontSet * FontLoader::GetFontSet(const std::filesystem::path& fontPath, uint16_t fontSize) {
		// look for existing entry
		if (const auto fontSetEntry = fontSets.find(fontPath); fontSetEntry != fontSets.end()) {
			if (auto sizeEntry = fontSetEntry->second.find(fontSize); sizeEntry != fontSetEntry->second.end()) {
				return sizeEntry->second.get();
			}
		}

		auto NewFontSet = std::make_unique<FontSet>();

		auto faceEntry = faces.find(fontPath);
		if (faceEntry == faces.end()) {
			if (!loadFont(fontPath)) {
				spdlog::error("Could not load font: {}", fontPath.string());
				return {};
			}
			// set faceEntry
			faceEntry = faces.find(fontPath);
		}

		auto face = faceEntry->second;
		if (FT_Set_Pixel_Sizes(face, 0, fontSize)) {
			spdlog::error("Could not set font size: {}", fontSize);
			return {};
		}

		auto characterImages = std::vector<std::unique_ptr<Image>>();
		auto characterDetails = std::unordered_map<char, CharacterDetails>();
		for (auto character : std::string(CharacterSet)) {
			// load the character
			if (FT_Load_Char(face, character, FT_LOAD_RENDER)) {
				spdlog::error("Could not load character: {}", character);
				continue;
			}

			auto characterImage = std::make_unique<Image>(face->glyph->bitmap.buffer, face->glyph->bitmap.width, face->glyph->bitmap.rows, 1);
			// characterImage->FlipPixels(true, false);
			characterImages.emplace_back(std::move(characterImage));

			auto charDetails = CharacterDetails {
				.Size = glm::vec2(face->glyph->bitmap.width, face->glyph->bitmap.rows),
				.Bearing = glm::vec2(face->glyph->bitmap_left, face->glyph->bitmap_top),
				.Advance = glm::vec2(face->glyph->advance.x, face->glyph->advance.y)
			};
			characterDetails[character] = charDetails;
		}

		auto [gridSize, imageSize, texture] = Image::MergeImages(characterImages);
		NewFontSet->Texture = std::move(texture);
		NewFontSet->Texture->FlipPixels(true, false);
		NewFontSet->Characters = characterDetails;
		NewFontSet->CharacterSize = imageSize;
		fontSets[fontPath][fontSize] = std::move(NewFontSet);

		auto* currentFontSet = fontSets[fontPath][fontSize].get();
		// now let's set the UV coordinates
		glm::vec2 currentGridPosition = {0.f, 0.f};
		for (auto character : std::string(CharacterSet)) {
			auto& details = currentFontSet->Characters[character];
			if (currentGridPosition.x >= gridSize.x) {
				currentGridPosition.x = 0.f;
				currentGridPosition.y++;
			}
			if (currentGridPosition.y >= gridSize.y) {
				spdlog::error("Font texture is too small for character set");
				return {};
			}

			auto uvYPosition = gridSize.y - currentGridPosition.y;
			auto uvStart = glm::vec2(currentGridPosition.x * imageSize.x,  uvYPosition * imageSize.y);
			glm::vec4 uv = {
				uvStart.x / static_cast<float>(currentFontSet->Texture->GetWidth()),
				(uvStart.y - details.Size.y) / static_cast<float>(currentFontSet->Texture->GetHeight()),
				(uvStart.x + details.Size.x) / static_cast<float>(currentFontSet->Texture->GetWidth()),
				uvStart.y / static_cast<float>(currentFontSet->Texture->GetHeight()),
			};

			details.UV = uv;
			currentGridPosition.x++;
		}
		return currentFontSet;
	}

	bool FontLoader::loadFont(const path &fontPath) {
		spdlog::info("Loading font from {}", fontPath.string());
		FT_Face face;
		// c_str to wide string
		if (FT_New_Face(library, fontPath.string().c_str(), 0, &face)) {
			spdlog::error("Could not load font: {}", fontPath.string());
			return false;
		}

		faces[fontPath] = face;
		return true;
	}

} // OZZ